// Epidom Dashboard MVP - Database Schema
// Food Inventory & Production Management System
// Next-auth (JWT) + Stripe Subscriptions

generator client {
  provider = "prisma-client-js"
}

generator dbml {
  provider = "prisma-dbml-generator"
  output   = "./dbml"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// NEXT-AUTH (JWT-based)
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  password      String
  emailVerified DateTime?
  image         String?

  // Profile settings
  phone         String?
  locale        String    @default("en") // en, fr, id
  timezone      String    @default("UTC")
  currency      String    @default("EUR")

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  business      Business?
  subscription  Subscription?
  alerts        Alert[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

// ============================================
// BUSINESS (1-to-1 with User)
// ============================================

model Business {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Business info
  name        String
  address     String?
  city        String?
  country     String?
  phone       String?
  email       String?
  logo        String?
  website     String?

  // Business settings
  currency    String   @default("EUR")
  timezone    String   @default("UTC")
  locale      String   @default("en")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  stores       Store[]

  @@map("businesses")
}

// ============================================
// STORE (Multi-outlet support)
// ============================================

model Store {
  id          String   @id @default(cuid())
  businessId  String
  business    Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  // Store info
  name        String
  address     String?
  city        String?
  country     String?
  phone       String?
  email       String?
  image       String?

  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations - all store data
  products         Product[]
  ingredients      Ingredient[]
  recipes          Recipe[]
  suppliers        Supplier[]
  orders           Order[]
  productionBatches ProductionBatch[]

  @@index([businessId])
  @@index([isActive])
  @@map("stores")
}

// ============================================
// STRIPE SUBSCRIPTIONS
// ============================================

enum SubscriptionPlan {
  STARTER     // €29/month
  PRO         // €79/month
  ENTERPRISE  // Custom pricing
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Stripe data
  stripeCustomerId     String             @unique
  stripeSubscriptionId String?            @unique
  stripePriceId        String?

  // Subscription details
  plan                 SubscriptionPlan   @default(STARTER)
  status               SubscriptionStatus @default(INCOMPLETE)

  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)

  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  @@map("subscriptions")
}

// ============================================
// INVENTORY MANAGEMENT
// ============================================

model Product {
  id              String    @id @default(cuid())
  storeId         String
  store           Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)

  sku             String    @unique
  name            String
  description     String?
  category        String?   // bread, pastries, cakes, etc.
  image           String?

  // Pricing
  costPrice       Decimal   @db.Decimal(10, 2)
  sellingPrice    Decimal   @db.Decimal(10, 2)

  // Stock
  currentStock    Decimal   @db.Decimal(10, 2) @default(0)
  unit            String    @default("piece") // piece, kg, box, etc.
  minStockLevel   Decimal   @db.Decimal(10, 2) @default(0)
  criticalLevel   Decimal?  @db.Decimal(10, 2) // for alerts

  // Production
  productionTime  Int?      // in minutes
  shelfLife       Int?      // in days

  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  recipe          Recipe?
  stockMovements  StockMovement[]
  productionBatches ProductionBatch[]
  orderItems      OrderItem[]

  @@index([storeId])
  @@index([category])
  @@index([isActive])
  @@map("products")
}

model Ingredient {
  id              String    @id @default(cuid())
  storeId         String
  store           Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)

  sku             String    @unique
  name            String
  description     String?
  category        String?   // flour, dairy, sugar, etc.
  image           String?

  // Purchasing
  unit            String    @default("kg") // kg, liter, piece, etc.
  unitCost        Decimal   @db.Decimal(10, 2)

  // Stock
  currentStock    Decimal   @db.Decimal(10, 2) @default(0)
  minStockLevel   Decimal   @db.Decimal(10, 2) @default(0)
  criticalLevel   Decimal?  @db.Decimal(10, 2)

  // Supplier info
  supplierId      String?
  supplier        Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)

  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  recipeIngredients RecipeIngredient[]
  stockMovements  StockMovement[]

  @@index([storeId])
  @@index([category])
  @@index([supplierId])
  @@index([isActive])
  @@map("ingredients")
}

// ============================================
// PRODUCTION & RECIPES
// ============================================

model Recipe {
  id              String    @id @default(cuid())
  storeId         String
  store           Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)

  productId       String    @unique
  product         Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  batchSize       Decimal   @db.Decimal(10, 2) // yield quantity
  batchUnit       String    @default("piece")
  instructions    String?   @db.Text

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  ingredients     RecipeIngredient[]
  productionBatches ProductionBatch[]

  @@index([storeId])
  @@map("recipes")
}

model RecipeIngredient {
  id              String     @id @default(cuid())
  recipeId        String
  recipe          Recipe     @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredientId    String
  ingredient      Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  quantity        Decimal    @db.Decimal(10, 3)
  unit            String

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@unique([recipeId, ingredientId])
  @@map("recipe_ingredients")
}

enum ProductionStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model ProductionBatch {
  id              String            @id @default(cuid())
  storeId         String
  store           Store             @relation(fields: [storeId], references: [id], onDelete: Cascade)

  batchNumber     String            @unique
  productId       String
  product         Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  recipeId        String?
  recipe          Recipe?           @relation(fields: [recipeId], references: [id], onDelete: SetNull)

  plannedQuantity Decimal           @db.Decimal(10, 2)
  actualQuantity  Decimal?          @db.Decimal(10, 2)
  unit            String

  status          ProductionStatus  @default(PLANNED)

  scheduledDate   DateTime
  completedDate   DateTime?

  notes           String?

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  stockMovements  StockMovement[]

  @@index([storeId])
  @@index([productId])
  @@index([status])
  @@index([scheduledDate])
  @@map("production_batches")
}

// ============================================
// STOCK TRACKING
// ============================================

enum MovementType {
  PURCHASE        // Receiving from supplier
  PRODUCTION_IN   // Finished goods from production
  PRODUCTION_OUT  // Ingredients used in production
  SALE            // Products sold to customer
  ADJUSTMENT      // Manual stock adjustment
  WASTE           // Spoilage, damage, expired
}

model StockMovement {
  id              String        @id @default(cuid())

  // Polymorphic relation - either product OR ingredient
  productId       String?
  product         Product?      @relation(fields: [productId], references: [id], onDelete: Cascade)
  ingredientId    String?
  ingredient      Ingredient?   @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  type            MovementType
  quantity        Decimal       @db.Decimal(10, 3)
  unit            String

  // Balance after this movement
  balanceAfter    Decimal       @db.Decimal(10, 3)

  // Optional references
  orderId         String?
  order           Order?        @relation(fields: [orderId], references: [id], onDelete: SetNull)
  productionBatchId String?
  productionBatch ProductionBatch? @relation(fields: [productionBatchId], references: [id], onDelete: SetNull)

  notes           String?
  createdAt       DateTime      @default(now())

  @@index([productId])
  @@index([ingredientId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

// ============================================
// SUPPLIERS
// ============================================

model Supplier {
  id              String    @id @default(cuid())
  storeId         String
  store           Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)

  name            String
  contactPerson   String?
  email           String?
  phone           String?

  address         String?
  city            String?
  country         String?

  notes           String?

  isActive        Boolean   @default(true)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  ingredients     Ingredient[]

  @@index([storeId])
  @@index([isActive])
  @@map("suppliers")
}

// ============================================
// CUSTOMER ORDERS
// ============================================

enum OrderStatus {
  PENDING
  CONFIRMED
  IN_PRODUCTION
  READY
  DELIVERED
  CANCELLED
}

model Order {
  id              String        @id @default(cuid())
  storeId         String
  store           Store         @relation(fields: [storeId], references: [id], onDelete: Cascade)

  orderNumber     String        @unique

  // Customer info (simplified - no separate customer table)
  customerName    String
  customerEmail   String?
  customerPhone   String?
  deliveryAddress String?

  status          OrderStatus   @default(PENDING)

  orderDate       DateTime      @default(now())
  dueDate         DateTime?
  deliveredDate   DateTime?

  subtotal        Decimal       @db.Decimal(10, 2)
  tax             Decimal       @db.Decimal(10, 2) @default(0)
  delivery        Decimal       @db.Decimal(10, 2) @default(0)
  total           Decimal       @db.Decimal(10, 2)

  notes           String?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  items           OrderItem[]
  stockMovements  StockMovement[]

  @@index([storeId])
  @@index([status])
  @@index([orderDate])
  @@index([dueDate])
  @@map("orders")
}

model OrderItem {
  id              String    @id @default(cuid())
  orderId         String
  order           Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId       String
  product         Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  quantity        Decimal   @db.Decimal(10, 2)
  unit            String
  unitPrice       Decimal   @db.Decimal(10, 2)
  total           Decimal   @db.Decimal(10, 2)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

// ============================================
// ALERTS & NOTIFICATIONS
// ============================================

enum AlertType {
  LOW_STOCK       // Stock below minimum level
  CRITICAL_STOCK  // Stock below critical level
  ORDER_DUE       // Order due date approaching
  PRODUCTION_DUE  // Production scheduled
  SYSTEM          // System notifications
}

enum AlertSeverity {
  INFO
  WARNING
  CRITICAL
}

model Alert {
  id              String        @id @default(cuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  type            AlertType
  severity        AlertSeverity @default(INFO)

  title           String
  message         String

  // Optional reference to related entity
  entityType      String?       // product, ingredient, order, production
  entityId        String?

  isRead          Boolean       @default(false)

  createdAt       DateTime      @default(now())

  @@index([userId, isRead])
  @@index([type])
  @@index([createdAt])
  @@map("alerts")
}
