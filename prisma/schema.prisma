// Epidom Dashboard MVP - Database Schema
// Food Manufacturer ERP for Single Bakery/Business
// No RBAC - Single account system

// generator client {
//  provider = "prisma-client-js"
// }

generator dbml {
  provider = "prisma-dbml-generator"
  output   = "./dbml"
}


datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTHENTICATION & BUSINESS
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String
  passwordHash  String
  avatar        String?
  phone         String?
  locale        String    @default("en") // en, fr, id
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  business      Business?
  alerts        Alert[]

  @@map("users")
}

model Business {
  id              String    @id @default(cuid())
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  name            String
  registrationNo  String?
  taxId           String?
  address         String?
  city            String?
  country         String?
  postalCode      String?
  phone           String?
  email           String?
  website         String?
  logo            String?

  // Business settings
  currency        String    @default("USD")
  timezone        String    @default("UTC")
  language        String    @default("en")

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("businesses")
}

// ============================================
// PRODUCT MANAGEMENT
// ============================================

model Product {
  id              String    @id @default(cuid())
  sku             String    @unique
  name            String
  description     String?
  category        String?   // bread, pastries, cakes, etc.
  image           String?

  // Pricing
  costPrice       Decimal   @db.Decimal(10, 2)
  sellingPrice    Decimal   @db.Decimal(10, 2)

  // Inventory
  unit            String    @default("piece") // piece, kg, box, etc.
  minStockLevel   Int       @default(0)
  maxStockLevel   Int?

  // Production
  productionTime  Int?      // in minutes
  shelfLife       Int?      // in days

  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  recipe          Recipe?
  inventory       Inventory[]
  productionBatches ProductionBatch[]
  orderItems      OrderItem[]

  @@index([category])
  @@index([isActive])
  @@map("products")
}

model Recipe {
  id              String    @id @default(cuid())
  productId       String    @unique
  product         Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  batchSize       Decimal   @db.Decimal(10, 2) // yield quantity
  batchUnit       String    @default("piece")
  instructions    String?   @db.Text

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  ingredients     RecipeIngredient[]

  @@map("recipes")
}

model Ingredient {
  id              String    @id @default(cuid())
  sku             String    @unique
  name            String
  description     String?
  category        String?   // flour, dairy, sugar, etc.

  // Purchasing
  unit            String    @default("kg") // kg, liter, piece, etc.
  unitCost        Decimal   @db.Decimal(10, 2)

  // Inventory
  minStockLevel   Decimal   @db.Decimal(10, 2) @default(0)
  maxStockLevel   Decimal?  @db.Decimal(10, 2)

  // Supplier info
  supplierId      String?
  supplier        Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  supplierSku     String?

  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  recipeIngredients RecipeIngredient[]
  inventory       Inventory[]
  purchaseOrderItems PurchaseOrderItem[]

  @@index([category])
  @@index([supplierId])
  @@index([isActive])
  @@map("ingredients")
}

model RecipeIngredient {
  id              String     @id @default(cuid())
  recipeId        String
  recipe          Recipe     @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredientId    String
  ingredient      Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  quantity        Decimal    @db.Decimal(10, 3)
  unit            String     // should match ingredient unit

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@unique([recipeId, ingredientId])
  @@map("recipe_ingredients")
}

// ============================================
// INVENTORY MANAGEMENT
// ============================================

model Inventory {
  id              String    @id @default(cuid())

  // Polymorphic relation - either product OR ingredient
  productId       String?
  product         Product?  @relation(fields: [productId], references: [id], onDelete: Cascade)
  ingredientId    String?
  ingredient      Ingredient? @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  quantity        Decimal   @db.Decimal(10, 3)
  unit            String
  location        String?   // warehouse location, shelf, etc.

  // Expiry tracking
  batchNumber     String?
  expiryDate      DateTime?

  lastStockTake   DateTime?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  transactions    InventoryTransaction[]

  @@index([productId])
  @@index([ingredientId])
  @@index([expiryDate])
  @@map("inventory")
}

enum TransactionType {
  PURCHASE        // Receiving from supplier
  PRODUCTION_IN   // Finished goods from production
  PRODUCTION_OUT  // Ingredients used in production
  SALE            // Products sold
  ADJUSTMENT      // Manual adjustment
  WASTE           // Spoilage, damage
  RETURN          // Customer return
}

model InventoryTransaction {
  id              String          @id @default(cuid())
  inventoryId     String
  inventory       Inventory       @relation(fields: [inventoryId], references: [id], onDelete: Cascade)

  type            TransactionType
  quantity        Decimal         @db.Decimal(10, 3)
  unit            String

  // References to related records
  productionBatchId String?
  productionBatch ProductionBatch? @relation(fields: [productionBatchId], references: [id], onDelete: SetNull)
  orderId         String?
  order           Order?          @relation(fields: [orderId], references: [id], onDelete: SetNull)
  purchaseOrderId String?
  purchaseOrder   PurchaseOrder?  @relation(fields: [purchaseOrderId], references: [id], onDelete: SetNull)

  notes           String?
  createdAt       DateTime        @default(now())

  @@index([inventoryId])
  @@index([type])
  @@index([createdAt])
  @@map("inventory_transactions")
}

// ============================================
// PRODUCTION MANAGEMENT
// ============================================

enum ProductionStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model ProductionBatch {
  id              String            @id @default(cuid())
  batchNumber     String            @unique
  productId       String
  product         Product           @relation(fields: [productId], references: [id], onDelete: Cascade)

  plannedQuantity Decimal           @db.Decimal(10, 2)
  actualQuantity  Decimal?          @db.Decimal(10, 2)
  unit            String

  status          ProductionStatus  @default(PLANNED)

  // Scheduling
  scheduledStart  DateTime
  scheduledEnd    DateTime?
  actualStart     DateTime?
  actualEnd       DateTime?

  // Quality & Cost
  quality         String?           // A, B, C grade
  productionCost  Decimal?          @db.Decimal(10, 2)

  notes           String?           @db.Text

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  transactions    InventoryTransaction[]

  @@index([productId])
  @@index([status])
  @@index([scheduledStart])
  @@map("production_batches")
}

// ============================================
// SUPPLIER & PURCHASING
// ============================================

model Supplier {
  id              String    @id @default(cuid())
  code            String    @unique
  name            String
  contactPerson   String?
  email           String?
  phone           String?

  address         String?
  city            String?
  country         String?
  postalCode      String?

  paymentTerms    String?   // Net 30, Net 60, etc.
  taxId           String?

  isActive        Boolean   @default(true)
  rating          Int?      @default(0) // 0-5 stars

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  ingredients     Ingredient[]
  purchaseOrders  PurchaseOrder[]

  @@index([isActive])
  @@map("suppliers")
}

enum PurchaseOrderStatus {
  DRAFT
  SENT
  CONFIRMED
  RECEIVED
  CANCELLED
}

model PurchaseOrder {
  id              String              @id @default(cuid())
  orderNumber     String              @unique
  supplierId      String
  supplier        Supplier            @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  status          PurchaseOrderStatus @default(DRAFT)

  orderDate       DateTime            @default(now())
  expectedDate    DateTime?
  receivedDate    DateTime?

  subtotal        Decimal             @db.Decimal(10, 2)
  tax             Decimal             @db.Decimal(10, 2) @default(0)
  shipping        Decimal             @db.Decimal(10, 2) @default(0)
  total           Decimal             @db.Decimal(10, 2)

  notes           String?             @db.Text

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  items           PurchaseOrderItem[]
  transactions    InventoryTransaction[]

  @@index([supplierId])
  @@index([status])
  @@index([orderDate])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String        @id @default(cuid())
  purchaseOrderId String
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  ingredientId    String
  ingredient      Ingredient    @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  quantity        Decimal       @db.Decimal(10, 3)
  unit            String
  unitPrice       Decimal       @db.Decimal(10, 2)
  total           Decimal       @db.Decimal(10, 2)

  receivedQuantity Decimal?     @db.Decimal(10, 3)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([purchaseOrderId])
  @@index([ingredientId])
  @@map("purchase_order_items")
}

// ============================================
// SALES & ORDERS
// ============================================

enum OrderStatus {
  PENDING
  CONFIRMED
  IN_PRODUCTION
  READY
  DELIVERED
  CANCELLED
}

model Order {
  id              String        @id @default(cuid())
  orderNumber     String        @unique

  // Customer info (simplified - no separate customer table for MVP)
  customerName    String
  customerEmail   String?
  customerPhone   String?
  deliveryAddress String?

  status          OrderStatus   @default(PENDING)

  orderDate       DateTime      @default(now())
  dueDate         DateTime?
  deliveredDate   DateTime?

  subtotal        Decimal       @db.Decimal(10, 2)
  tax             Decimal       @db.Decimal(10, 2) @default(0)
  delivery        Decimal       @db.Decimal(10, 2) @default(0)
  total           Decimal       @db.Decimal(10, 2)

  notes           String?       @db.Text

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  items           OrderItem[]
  transactions    InventoryTransaction[]

  @@index([status])
  @@index([orderDate])
  @@index([dueDate])
  @@map("orders")
}

model OrderItem {
  id              String    @id @default(cuid())
  orderId         String
  order           Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId       String
  product         Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  quantity        Decimal   @db.Decimal(10, 2)
  unit            String
  unitPrice       Decimal   @db.Decimal(10, 2)
  total           Decimal   @db.Decimal(10, 2)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

// ============================================
// ALERTS & NOTIFICATIONS
// ============================================

enum AlertType {
  LOW_STOCK
  EXPIRING_SOON
  EXPIRED
  PRODUCTION_DELAYED
  ORDER_DUE
  SYSTEM
}

enum AlertSeverity {
  INFO
  WARNING
  CRITICAL
}

model Alert {
  id              String        @id @default(cuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  type            AlertType
  severity        AlertSeverity @default(INFO)

  title           String
  message         String        @db.Text

  // Optional reference to related entity
  entityType      String?       // product, ingredient, order, etc.
  entityId        String?

  isRead          Boolean       @default(false)
  isDismissed     Boolean       @default(false)

  createdAt       DateTime      @default(now())

  @@index([userId])
  @@index([type])
  @@index([isRead])
  @@index([createdAt])
  @@map("alerts")
}

// ============================================
// SYSTEM SETTINGS
// ============================================

model Setting {
  id              String    @id @default(cuid())
  key             String    @unique
  value           String    @db.Text
  description     String?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("settings")
}
